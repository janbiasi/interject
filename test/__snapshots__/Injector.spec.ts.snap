// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Injector basics should be creatable with providers 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "withProvidersToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "withProvidersToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": 10,
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector basics should be creatable without providers 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector inheritance should resolve from parent 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "inheritProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "inheritProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": 10,
    },
  },
  "parent": Injector {
    "_injections": Map {
      [Function] => Object {
        "dependencies": Array [],
        "factory": [Function],
        "token": [Function],
        "useNew": false,
        "value": [Circular],
      },
      InjectionToken {
        "_id": "inheritProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      } => Object {
        "dependencies": Array [],
        "factory": [Function],
        "token": InjectionToken {
          "_id": "inheritProviderToken",
          "injectable": Object {
            "factory": [Function],
            "scope": "root",
            "value": undefined,
          },
          "metadataName": "InjectionToken",
        },
        "useNew": false,
        "value": 10,
      },
    },
    "parent": NullInjector {},
    "source": null,
  },
  "source": null,
}
`;

exports[`Injector inheritance should resolve from parent 2`] = `
"Injector { class CommonInjector {
    static create(options, parent) {
        /* istanbul ignore next */cov_1xe72mqcsz.f[1]++;
        cov_1xe72mqcsz.s[7]++;

        if (Array.isArray(options)) {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][0]++;
            cov_1xe72mqcsz.s[8]++;

            return new Injector_1.Injector(options, parent);
        } else {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][1]++;
            cov_1xe72mqcsz.s[9]++;

            return new Injector_1.Injector(options.providers, options.parent, /* istanbul ignore next */(cov_1xe72mqcsz.b[3][0]++, options.name) || /* istanbul ignore next */(cov_1xe72mqcsz.b[3][1]++, null));
        }
    }
    toString() {
        /* istanbul ignore next */cov_1xe72mqcsz.f[2]++;
        cov_1xe72mqcsz.s[10]++;

        return \`CommonInjector { }\`;
    }
}, InjectionToken { inheritProviderToken } }"
`;

exports[`Injector specific providers ClassProvider should resolve a single class from a provider 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "classProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "classProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": true,
      "value": TestService {},
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers ClassProvider should resolve a single class from a provider 2`] = `
"Injector { class CommonInjector {
    static create(options, parent) {
        /* istanbul ignore next */cov_1xe72mqcsz.f[1]++;
        cov_1xe72mqcsz.s[7]++;

        if (Array.isArray(options)) {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][0]++;
            cov_1xe72mqcsz.s[8]++;

            return new Injector_1.Injector(options, parent);
        } else {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][1]++;
            cov_1xe72mqcsz.s[9]++;

            return new Injector_1.Injector(options.providers, options.parent, /* istanbul ignore next */(cov_1xe72mqcsz.b[3][0]++, options.name) || /* istanbul ignore next */(cov_1xe72mqcsz.b[3][1]++, null));
        }
    }
    toString() {
        /* istanbul ignore next */cov_1xe72mqcsz.f[2]++;
        cov_1xe72mqcsz.s[10]++;

        return \`CommonInjector { }\`;
    }
}, InjectionToken { classProviderToken } }"
`;

exports[`Injector specific providers ClassProvider should resolve multiple request to the same instance 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "singletonClassProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "singletonClassProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": true,
      "value": TestService {},
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers ClassProvider should resolve multiple request to the same instance 2`] = `
"Injector { class CommonInjector {
    static create(options, parent) {
        /* istanbul ignore next */cov_1xe72mqcsz.f[1]++;
        cov_1xe72mqcsz.s[7]++;

        if (Array.isArray(options)) {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][0]++;
            cov_1xe72mqcsz.s[8]++;

            return new Injector_1.Injector(options, parent);
        } else {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][1]++;
            cov_1xe72mqcsz.s[9]++;

            return new Injector_1.Injector(options.providers, options.parent, /* istanbul ignore next */(cov_1xe72mqcsz.b[3][0]++, options.name) || /* istanbul ignore next */(cov_1xe72mqcsz.b[3][1]++, null));
        }
    }
    toString() {
        /* istanbul ignore next */cov_1xe72mqcsz.f[2]++;
        cov_1xe72mqcsz.s[10]++;

        return \`CommonInjector { }\`;
    }
}, InjectionToken { singletonClassProviderToken } }"
`;

exports[`Injector specific providers FactoryProvider should execute the factory only once 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "multiFactoryProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "multiFactoryProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": Object {
        "value": Array [
          "value",
        ],
      },
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers FactoryProvider should resolve the factory value correctly 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "factoryProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "factoryProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": Object {
        "value": Array [
          "value",
        ],
      },
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers ValueProvider should resolve a single value from a value provider 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "valueProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": InjectionToken {
        "_id": "valueProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": 10,
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers ValueProvider should resolve a single value from a value provider 2`] = `
"Injector { class CommonInjector {
    static create(options, parent) {
        /* istanbul ignore next */cov_1xe72mqcsz.f[1]++;
        cov_1xe72mqcsz.s[7]++;

        if (Array.isArray(options)) {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][0]++;
            cov_1xe72mqcsz.s[8]++;

            return new Injector_1.Injector(options, parent);
        } else {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][1]++;
            cov_1xe72mqcsz.s[9]++;

            return new Injector_1.Injector(options.providers, options.parent, /* istanbul ignore next */(cov_1xe72mqcsz.b[3][0]++, options.name) || /* istanbul ignore next */(cov_1xe72mqcsz.b[3][1]++, null));
        }
    }
    toString() {
        /* istanbul ignore next */cov_1xe72mqcsz.f[2]++;
        cov_1xe72mqcsz.s[10]++;

        return \`CommonInjector { }\`;
    }
}, InjectionToken { valueProviderToken } }"
`;

exports[`Injector specific providers ValueProvider should resolve multiple values from a value provider 1`] = `
Injector {
  "_injections": Map {
    [Function] => Object {
      "dependencies": Array [],
      "factory": [Function],
      "token": [Function],
      "useNew": false,
      "value": [Circular],
    },
    InjectionToken {
      "_id": "multiProviderToken",
      "injectable": Object {
        "factory": [Function],
        "scope": "root",
        "value": undefined,
      },
      "metadataName": "InjectionToken",
    } => Object {
      "dependencies": Array [],
      "factory": undefined,
      "token": InjectionToken {
        "_id": "multiProviderToken",
        "injectable": Object {
          "factory": [Function],
          "scope": "root",
          "value": undefined,
        },
        "metadataName": "InjectionToken",
      },
      "useNew": false,
      "value": Array [
        10,
        20,
      ],
    },
  },
  "parent": NullInjector {},
  "source": null,
}
`;

exports[`Injector specific providers ValueProvider should resolve multiple values from a value provider 2`] = `
"Injector { class CommonInjector {
    static create(options, parent) {
        /* istanbul ignore next */cov_1xe72mqcsz.f[1]++;
        cov_1xe72mqcsz.s[7]++;

        if (Array.isArray(options)) {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][0]++;
            cov_1xe72mqcsz.s[8]++;

            return new Injector_1.Injector(options, parent);
        } else {
            /* istanbul ignore next */cov_1xe72mqcsz.b[2][1]++;
            cov_1xe72mqcsz.s[9]++;

            return new Injector_1.Injector(options.providers, options.parent, /* istanbul ignore next */(cov_1xe72mqcsz.b[3][0]++, options.name) || /* istanbul ignore next */(cov_1xe72mqcsz.b[3][1]++, null));
        }
    }
    toString() {
        /* istanbul ignore next */cov_1xe72mqcsz.f[2]++;
        cov_1xe72mqcsz.s[10]++;

        return \`CommonInjector { }\`;
    }
}, InjectionToken { multiProviderToken } }"
`;
